\chapter{Conclusiones y trabajo futuro}\label{chapter:4}
En este trabajo se han investigado las metaheurísticas, más en particular aquellas basadas en métodos evolutivos. En primer lugar, se han tratado los métodos de búsqueda en general, haciendo hincapié en los métodos de búsquedas locales y los métodos de búsqueda por poblaciones. Dentro de los segundos, se han estudiado los algoritmos genéticos en profundidad, viendo su funcionamiento, sus principales operadores, sus problemas y los motivos por los que estos funcionan. Utilizando estas ideas como base, se ha dado paso a una metaheurística que busca unir las búsquedas locales y los algoritmos evolutivos, combinación muy potente para los problemas de rutas, los algoritmos meméticos. Dentro de estos algoritmos se han tratado sus principales características, así como su funcionamiento para la resolución de problemas complejos. Gracias a esta información, se puede ver la importancia de las metaheurísticas, como métodos aproximados con una base matemática potente, que permiten la resolución de problemas complejos rápidamente. Uno de estos problemas son los problemas de rutas, que han sido estudiados, para poder comprender el problema que se busca resolver, el MC-TTRP. Este problema es $NP$-duro, lo que hace que sea necesario el uso de algoritmos aproximados, como el que ha sido desarrollado.\\

El algoritmo desarrollado ha sido un algoritmo memético que permite la resolución veloz del MC-TTRP. Este algoritmo ha sido probado frente a otras metaheurísticas (búsqueda tabú) y solucionadores con métodos exactos (Gurobi). Los resultados obtenidos son peores que los de la búsqueda tabú para casos complejos, con un gran número de clientes distribuidos de manera aleatoria. En estos casos (aunque hay que tener en cuenta la restricción extra añadida), los resultados son aproximadamente un $29\%$ peores relativamente a las soluciones dadas por la búsqeuda tabú. Sin embargo, para casos pequeños, los resultados son comparables en resultado al algoritmo exacto, mientras que el tiempo requerido es sustancialmente inferior.\\

Estos resultados obtenidos podrían ser mejorados de múltiples maneras tanto en coste como en tiempo, para ello veamos las posibles ampliaciones que podrían ser realizadas en un futuro:
\begin{itemize}
    \item La principal mejora es el cambio del código para eliminar la restricción extra de las subrutas y añadir todas las restricciones tomadas en el problema MC-TTRP original propuesto en \cite{laura-mcttrp}. Podríamos realizar esta modificación sin variar los cromosomas GVR, añadiendo las subrutas como una ruta más del conjunto general. Sin embargo, sería necesario almacenar también desde donde comienza cada una de las rutas añadiendo a los cromosomas un valor: 0, en caso de comenzar en el depósito y $t$ en caso de ser una subruta con parking en el nodo $t$. Esto, no obstante, añadiría problemas a la realización de los operadores que han sido utilizados. Veamos las modificaciones necesarias:
    \begin{itemize}
        \item En primer lugar, nace la complicación de la generación de una población. En este caso las rutas que comenzasen en un cliente TC tendrían una probabilidad de convertirse en subrutas. Cada una de las subrutas podría comenzar, por ejemplo, en el cliente VC que más cerca estuviese de la primera parada de la subruta.
        \item Para la operación de cruce, el origen de las subrutas no se modifica (ya que nunca insertamos una subruta al inicio de otra), sin embargo, lo más probable es que se generase un mayor número de rutas no factibles.
        \item La función de \textit{S-Split}, que hasta ahora garantizaba la factibilidad de las soluciones tendría que ser modificada considerablemente. Dentro de estos cambios, habría que incluir una decisión sobre cuándo contar una ruta de camión como una subruta, obligando a que las rutas que comienzan por un cliente VC sólo contengan clientes de este tipo.
        \item La operación de mutación se podría mantener igual, sin embargo, para mejorar la eficiencia del código, dentro de la subruta a invertir, no se tomaría nunca el primer elemento. De esta manera se mantiene la factibilidad, ya que las subrutas están separadas completamente de la subruta a la que hacen referencia y nunca se variaría el tipo de ruta.
        \item Las operaciones de búsqueda local se podrían mantener de manera idéntica a las anteriores, ya que siempre mantienen la factibilidad de la solución.
        \item Sería necesario añadir una nueva búsqueda local sobre las subrutas. Esta operación actuaría sobre una de las subrutas de la solución. Debido a que la adición de nuevos elementos a las subrutas ya se realizaría mediante cruce, esta operación buscaría intercambiar tanto los nodos de partida y de regreso de la subruta, como la elección de un mejor lugar de parking, con la única restricción de que un mismo cliente no puede ser parking de 2 subrutas. Esta operación serviría para moverse por soluciones del vecindario y mejorar el coste de la solución gracias a la \textbf{relocalización de subrutas}, por lo que este sería su nombre.
    \end{itemize}
    Añadiendo estas modificaciones, además de aquellas necesarias para tener en cuenta el tiempo máximo de uso de los vehículos (cálculo simple dentro de la función \textit{S-Split}), podríamos realizar una comparación más justa con los casos de prueba utilizados en el Capítulo \ref{chapter:3}.
    \item En múltiples artículos, como en \cite{MC-VRP-Memetic-ElFallahi,laura-mcttrp}, se utiliza una heurística para obtener una solución inicial de calidad. Esta heurística es conocida como la heurística de ahorros de Clarke y Wright \cite{clarke-1964}. Utilizando esta heurística, se podría dotar a la población de soluciones de buena calidad sobre las que iniciar el algoritmo. Sin embargo, no se usarían únicamente soluciones generadas por esta heurística, sino que la población inicial estaría formada por soluciones encontradas a partir de esta heurística y de soluciones generadas de manera aleatoria. De esta manera se tendría un buen balance para la ejecución del algoritmo genético. Más concretamente, en \cite{MC-VRP-Memetic-ElFallahi} se puede observar que aunque no siempre se consiguen mejores resultados con el uso de la heurística, se pueden conseguir mejores soluciones, sobre todo para casos complicados.
    \item Optimización del código. Esta optimización no solo hace referencia al flujo de las funciones utilizadas, sino, ya que se utiliza C++, es posible realizar una optimización del código a nivel muy bajo de abstracción. Dentro de estas optimizaciones podemos encontrar la utilización de operaciones vectorizadas, la definición de variables directamente en registros, el uso de estructuras de memoria más eficientes que los vectores, \ldots
    \item Estudio de los parámetros del problema. Sería muy interesante estudiar cuáles son los parámetros que consiguen un mejor valor medio en la solución del MC-TTRP.
    \item Modificación del tipo de paralelización. Como se comenta en la Sección \ref{section:materiales-software}, se ha utilizado OpenMP para la paralelización, sin embargo, existen otras librerías que permiten ejecuciones más rápidas en un contexto distribuido (como es el supercomputador del CESGA). Un ejemplo es Open MPI, que utiliza un estándar de paralelización basado en el paso de mensajes. Esta librería permitiría realizar una mejor paralelización con el beneficio de poder usar poblaciones más grandes, ya que OpenMP solo puede ser utilizada en un nodo del CESGA (64 individuos).
\end{itemize}

En definitiva, este trabajo ha demostrado la viabilidad y el potencial de los algoritmos meméticos en la resolución de problemas de rutas, destacando su capacidad para obtener soluciones de alta calidad en bajo tiempo. Los resultados obtenidos, junto con las líneas futuras propuestas, constituyen una base sólida para investigaciones posteriores orientadas a la mejora de la eficiencia computacional y la mejora de las soluciones obtenidas, pudiendo competir con los algoritmos más punteros de la actualidad.